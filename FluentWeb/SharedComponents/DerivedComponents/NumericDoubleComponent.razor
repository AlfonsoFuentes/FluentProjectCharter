@*﻿<FluentStack Orientation="Orientation.Vertical" Width="100%">
    <MudField  Typo="Typo.Body"><strong>@Label</strong></MudField >
       <FluentTextField Value="@value"
                     ValueChanged="OnStringValueChange"
                     Style="width: 100%;"
                     Placeholder="@PlaceHolder"
                     TextFieldType="@TextFieldType"
                     InputMode="@InputMode"
                     Immediate=true
                     Disabled="@Disable" /> 
    <FluentNumberField @bind-Value="@Value"
                       Disabled=@Disable
                       Immediate=true
                       HideStep=true
                       Style="width:100%"
                       @oninput="@((arg)=>OnStringValueChange(arg))"></FluentNumberField>
</FluentStack>
*@
@code {
    // string value => ValueRounded.ToString();
    // // public TextFieldType TextFieldType { get; set; } = TextFieldType.Number;
    // // public InputMode InputMode { get; set; } = InputMode.Decimal;
    // [Parameter]
    // public bool Disable { get; set; } = false;
    // [Parameter]
    // public string Label { get; set; } = string.Empty;
    // [Parameter]
    // public string PlaceHolder { get; set; } = string.Empty;
    // [Parameter]
    // public double Value { get; set; } = 0.0;
    // [Parameter]
    // public EventCallback<double> ValueChanged { get; set; }
    // [Parameter]

    // public EventCallback Validate { get; set; }

    // [Parameter]
    // public EventCallback<double> Change { get; set; }

    // public async Task OnValueChanged(double value)
    // {
    //     Value = value;
    //     await ValueChanged.InvokeAsync(Value);

    //     if (Change.HasDelegate) await Change.InvokeAsync(Value);
    //     if (Validate.HasDelegate) await Validate.InvokeAsync();

    // }
    // async Task OnStringValueChange(ChangeEventArgs arg)
    // {
    //     if (arg == null) return;

    //     string value = arg.Value!.ToString();
    //     double result = 0;
    //     if (double.TryParse(value, out result))
    //     {

    //         await OnValueChanged(result);
    //     }

    // }

    // public double ValueRounded => Math.Round(Value, GetDecimalPlaces(Value));
    // // Método para determinar cuántos decimales mostrar
    // private int GetDecimalPlaces(double value)
    // {
    //     if (value >= 1 || value == 0)
    //         return 2; // Por defecto, muestra 2 decimales para valores mayores o iguales a 1

    //     // Convertir el valor a una cadena sin notación científica
    //     string valueStr = value.ToString("G17", System.Globalization.CultureInfo.InvariantCulture);

    //     // Encontrar la posición del primer dígito significativo después del punto decimal
    //     int decimalIndex = valueStr.IndexOf('.');
    //     if (decimalIndex == -1)
    //         return 2; // Si no hay punto decimal, asumimos 2 decimales

    //     int firstSignificantDigitIndex = valueStr.Skip(decimalIndex + 1).TakeWhile(c => c == '0').Count() + decimalIndex + 1;

    //     // El número de decimales es la posición del primer dígito significativo menos la posición del punto decimal
    //     return firstSignificantDigitIndex - decimalIndex;
    // }

}
